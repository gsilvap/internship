%!TEX root = main.tex
% \newpage
\section{State of the Art}

Nowadays, people use a lot of services based in cloud and many of companies choose to use them too. Using it, companies reduce the costs of IT infrastructure and don't need to buy ``physical storage'' and don't care where are the data. The cloud service provides that the data is secure.
But, like as any system, the cloud have problems \red{such as} another computer systems, software and hardware faults. Very important is the resilience of the cloud too.

The increased use of cloud is related to a low usage of many dedicated servers, lower voltage levels, reduction of noise margins and increasing clock rates \cite{wolter2012resilience}. The cloud providers offers resources ready to deliver \cite{wolter2012resilience}.

With this work, I pretend to inject software faults and analyze how the system react to them.

There are many studies showing that the software faults\cite{avizzienisbasic} it's the main cause of computer failures.
About 44\% of the software faults cannot be emulated \cite{madeira2000emulation}.

%In this work
%deliberate how


% \marginnote{especificar as abreviaturas...}[0cm]
% \ac{cots}
% \ac{g-swfit}
% \ac{odc}
% \ac{swifi}

I have the opportunity to access to the application (executable only, not the source) of Robert Natella, called by SAFE, that inject software faults, as I also want to do (I will describe it in next section).

\subsection{Software Implemented Fault Injection of Software Faults}
In the next subsections I will describe some fault injectors that have been previously done.\\

\textbf{SAFE by Robert Natella}\\
% \subsubsection{SAFE by Robert Natella}

Safe is an application to inject realistic software faults in programs codded in C and C++.
This tool uses MCPP as parser, to get the tree of code. The decision of use MCPP instead of GCC parser was a workaround for some of the shortcomings of the GCC's C preprocessor.

\red{After that, write some files, variations of original files (code with simple mutations) with operators applied.}
Robert Natella implemented thirteen operators in SAFE, same as João Durães\cite{duraes2006emulation}, but with the difference that Robert \red{sinonimo: implemented} at source code level, and João at binary level.\\


\textbf{JACA Tool}\\
% \subsubsection{JACA Tool}

JACA\cite{regina2003jaca} is a tool taht have been made to validate Java applications. It injects high-level software faults and is based on computational reflection to inject interface faults in Java applications
\cite{martins2002jaca} \\

\textbf{J-SWFIT} \\

Java Software Fault Injection Tool\cite{sanches2011j} is a tool that don't need the source code to perform the injection, the mutation of the code is performed directly at byte-code level.


\subsection{ODC Model}
\ac{odc}\cite{bridge1998orthogonal} Model is a framework developed by IBM\cite{chillarege2004orthogonal}, created to improve the level of technology available to assist the decisions of a software engineer, via measurement and analysis.
ODC can be used to classifying and analyzing defects during software development.

%\cite{lyu1996handbook}
For that, this model have eight categories:

\begin{itemize}
	\item \textbf{Function} - This defect affects significant capability, end-user features, product \ac{api}, interface with hardware architecture, or global structure(s). It would require a formal design change.
	\item \textbf{Assignment} - Typically an assignment defect indicates an initialization of control blocks or an data structure.
	\item \textbf{Interface} - Problems in the interaction with other components, modules, device drivers, call statements, control blocks, or parameter lists.
	\item \textbf{Checking} - Based in the program logic that is checked and failed to validate data and values before the usage, loop conditions, etc.
	\item \textbf{Timing/serialization} - Errors that happen in shared and real-time resources.
	\item \textbf{Build/package/merge} - Errors that occur in the integration of library systems, management of changes, or in version control.
	\item \textbf{Documentation} - Errors in the documentation, that con be propagated to publications and maintenance notes.
	\item \textbf{Algorithm} - Problems that can be fixed by reimplementing an algorithm or local data structure, include efficiency or correctness that affect the task.
\end{itemize}


\newpage
\section{Research objectives and approach method}

In this section are discussed the main aspects in study.

\subsection{Cloud Computing}

Three levels of Cloud Computing Service Models:

\begin{itemize}
	\item \textbf{\ac{iaas}} - as the name suggests, provides an computing infrastructure, such as virtual machines, firewalls, load balancers, IP addresses, virtual local area networks and others. Examples: Amazon EC2, Windows Azure.

	\item \textbf{\ac{paas}} - provides an computing platform, normally includes operating system, programming language execution environment, database, web server and others. Examples: AWS Elastic Beanstalk, Windows Azure, Heroku.

	\item \textbf{\ac{saas}} - provides access to application softwares ofter referred as \textit{on-demand self-service} sofwares. Use it without install, setup and run the application. Service provider do all things for you. Google Apps, Microsoft Office 365.

\end{itemize}

The cloud computing isn't free of external disturbances\cite{wolter2012resilience}, the most important are:
\begin{itemize}
 	\item Security attacks;
 	\item Accidents;
 	\item Power surges;
 	\item Workload faults;
 	\item Malfunction;
 	\item Worms;
 	\item \ac{ddos} attacks.
 \end{itemize}


\subsection{Tools - GCC Parser, Bison and Eclipse CDT}

In the beginning of planning the basic software without any user interface, it was necessary to research the best applications, as the best way for using them to obtain panned results (fault injector).
For that, I thought that I could use the same tools that I have used in Compilers course, Lex and Yacc.

\red{For parsing the code, analyze and modify it,}

% Finally, I decided to use
In the end, I selected Eclipse CDT Plugin as standalone (only import libraries to project), because of my habilities in programming in Java Language, the maintainability of software, the low learning level than the developers need to modify it.\\

\textbf{GCC Parser}\\

Nowadays, GCC use a hand-written parser to improve syntactic error diagnostics, giving human meaningful messages on syntax errors.\\

\textbf{Eclipse CDT}\\

Eclipse CDT, as the name suggests, is an plugin for Eclipse that provides a fully functional C and C++ Integrated Development Environment.
Some of the features included in this plugin that are interesting for this project are:
\begin{itemize}
	\item Source navigation;
	\item Code editor with syntax highlighting;
	\item Source code refactoring and code generation.
\end{itemize}

Is possible to use this plugin in standalone mode, importing .jar files to the project.
Using it I can code Fault Injector in Java, making the software more maintainable and easy to use, write, compile and debug.
\\

\red{Problems with the rewriting of tree}

\red{Reflection}

\red{But I was forced to take decisions after that, for example, after create the tree of code, I can go through the tree in the recursive way or using \textit{Visitor Pattern}.}

\red{Performance analyses}

\newpage
% \section{Current work and preliminary results}
\section{Fault Injector Development}

The Fault Injector currently in development is coded in Java and

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=1\textwidth]{mockup.png}
\caption{\small \sl Overview of the injection tool.\label{fig:mockup}}
\end{center}
\end{figure}

\begin{table}[!ht]
\begin{tabular}{l|l}
\hline
Fault Type & Description                                            \\ \hline
MFC        & Missing function call                                  \\
MVIV       & Missing variable initialization using a value          \\
MVAV       & Missing variable assignment using a value              \\
MVAE       & Missing variable assignment with an expression         \\
MIA        & Missing IF construct around statements                 \\
MIFS       & Missing IF construct + statements                      \\
MIEB       & Missing IF construct + statements + ELSE construct     \\
MLAC       & Missing AND in expression used as branch condition     \\
MLOC       & Missing OR in expression used as branch condition      \\
MLPA       & Missing small and localized part of the algorithm      \\
WVAV       & Wrong value assigned to variable                       \\
WPFV       & Wrong variable used in parameter of function call      \\
WAEP       & Wrong arithmetic expression in function call parameter \\
		   & \red{add another faults}								\\ \hline
\end{tabular}
\caption{\small \sl Faults.\label{tab:faults}}
\end{table}

\begin{table}[!ht]
\begin{tabular}{c}
\includegraphics[width=1\textwidth]{img/representative_faults.jpg}
\end{tabular}
\caption{\small \sl Representativeness faults.\label{tab:representative_faults}}
\end{table}

\subsection{Generate derivations}

I chose to use the most representative faults \cite{duraes2006emulation}, divided into missing, wrong and extraneous, specified individually further down:

\red{Table of more representative faults of Durães}

\subsubsection{Fault Types - Missing}
\begin{itemize}
	\item \textbf{MIFS} - if construct plus statements

	This operator is based in the remotion of one conditional if. To do that, I need to verify the constraints c02, c08 and c09.
	\item \textbf{MLAC} - AND sub-expression in expression used as branch condition
	\item \textbf{MFC}  - function call
	\item \textbf{MIA}  - if construct around statements
	\item \textbf{MLOC} - OR sub-expression in expression used as branch condition
	\item \textbf{MLPA} - small and localized part of the algorithm
	\item \textbf{MVAE} - variable assignment using an expression
	\item \textbf{MFCT} - functionality
	\item \textbf{MVAV} - variable assignment using an value
	\item \textbf{MIEB} - if construct plus statements plus else before statements
	\item \textbf{MVIV} - variable initialization
\end{itemize}

\subsubsection{Fault Types - Wrong}
\begin{itemize}
	\item \textbf{WLEC} - logical expression used as branch condition
	\item \textbf{WALL} - algorithm - large modifications
	\item \textbf{WVAV} - value assigned to variable
	\item \textbf{WAEP} - arithmetic expression in parameter of function call
	\item \textbf{WSUT} - data types or conversion used
	\item \textbf{WPFV} - variable used in parameter of function call
\end{itemize}

\subsubsection{Fault Types - Extraneous}
\begin{itemize}
	\item \textbf{EVAV} - variable assignment using another variable
\end{itemize}

\subsection{Constraints}

The constraints defined below was specified by João Durães in ... .

\begin{table}[!ht]
\centering
\begin{tabular}{|c|p{12cm}|}
\hline
\textbf{Constraints}            & \multicolumn{1}{c|}{\textbf{Description}}                                     \\ \hline \hline
\textbf{C01}       \label{C01}  & Return value of the function \textbf{must not} being used                              \\ \hline
\textbf{C02}       \label{C02}  & Call \textbf{must not be} the only statement in the block                              \\ \hline
\textbf{C03}       \label{C03}  & Variable \textbf{must be} inside stack frame                                           \\ \hline
\textbf{C04}       \label{C04}  & \textbf{Must be} the first assignment for that variable in the module                  \\ \hline
\textbf{C05}       \label{C05}  & Assignment \textbf{must not be} inside a loop                                          \\ \hline
\textbf{C06}       \label{C06}  & Assignment \textbf{must not be} part of a for construct                                \\ \hline
\textbf{C07}       \label{C07}  & \textbf{Must not be} the first assignment for that variable in the module              \\ \hline
\textbf{C08}       \label{C08}  & The if construct \textbf{must not be} associated to an else construct                  \\ \hline
\textbf{C09}       \label{C09}  & Statements \textbf{must not include more than} five statements and not include loops   \\ \hline
\textbf{C10}       \label{C010} & Statements are in the same block, \textbf{do not include more than} 5 stats. not loops \\ \hline
\textbf{C11}       \label{C011} & There \textbf{must be} at least two variables in this module                           \\ \hline
\end{tabular}
\end{table}

\clearpage
\subsection{Applications to inject faults}

\red{The same applications that João Durães have collect information?}

\begin{itemize}
	\item MinGW, Last Update: 2015-06-08
	\item ScummVM, Last Update: 2015-05-17
	\item CDEX, Last Update: 2015-04-24
	\item FireBird, Last Update: 2015-04-15
	\item Joe, Last Update: 2015-03-22
	\item FreeCiv, Last Update: 2015-03-14
	\item GAIM or Pidgin, Last Update: 2015-01-07
	\item BASH, Last Update: 2013-12-10
	\item ZSNES, Last Update: 2013-05-07
	\item VIM, Last Update: 2013-04-25
	\item pdftohtml, Last Update: 2013-04-24
	%\item LKERNEL
\end{itemize}

\newpage
\section{Work plan and implications}

Built three separated modules:

\begin{itemize}
	\item Generate the derivations of main code of selected programs;
	\item Verify and analyze the effect of produced faults;
	\item Compile the programs with injected faults, by using make file.
\end{itemize}

\subsection{Analyze the effects}

The fault injected results is equal to the real software faults?




\subsection{Compile programs}

\red{Select five to ten programs to be tested.}

\red{Justificar a utilização de patchs}

After the compilation and execution of the programs, the results need to be evaluate. For measure that, I will use the \textit{CRASH Scale}\cite{koopman1997comparing}:

\begin{itemize}
	\item \textbf{C}atastrophic - Operating System crashed or multiple tasks affected;
	\item \textbf{R}estart - Task or process hangs, requiring restart;
	\item \textbf{A}bort - Task or process aborts abnormally (i.e. ``code dump'' or ``segmentation violation'');
	\item \textbf{S}ilent - Test Process exits without error code returned when one should be;
	\item \textbf{H}indering - Test Process exits with an error code not relevant to the situation or incorrect error code returned;
	\item \textbf{P}ass - The module exits properly, possibly with an appropriate error core.
\end{itemize}

This \textit{CRASH Scale} is one way to show results of the effect of faults on an end-use system.